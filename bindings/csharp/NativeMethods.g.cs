// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace prs_rs.Net.Sys
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "prs_rs";



        /// <summary>Compresses the given data in `source`, placing it in `destimation`.  Parameters  - `src`: A pointer to the compressed data. - `src_len`: Length of the compressed data. - `destination`: A pointer to the decompressed data to be written.  # Returns  Number of bytes written to `destination`.  # Safety  It's safe as long as `dest` has sufficient length (max length: [`crate::util::prs_calculate_max_decompressed_size`]) and the remaining parameters are valid.</summary>
        [DllImport(__DllName, EntryPoint = "prs_compress", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint prs_compress(byte* src, byte* dest, nuint src_len);

        /// <summary>Decodes the maximum possible compressed size after compressing a file with provided `source_len` length.  # Parameters  - `source_len`: Length of the compressed data.  # Returns  The length of the decompressed data at `source`.  # Remarks  A properly compressed PRS file has a theoretical maximum size of 1.125 times the size of the original input. i.e. (1 byte for every 8 bytes of input).  Up to 2 bytes may be added to that in addition, namely via: - Rounding file to next byte - Having to write 00 opcode after a compressed sequence of bytes to terminate.</summary>
        [DllImport(__DllName, EntryPoint = "prs_calculate_max_compressed_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint prs_calculate_max_compressed_size(nuint source_len);

        /// <summary>Decodes the compressed data at `source` without performing the actual decompression.  You can use this operation to determine the size of the data to decompress without actually decompressing the data to a buffer.  # Parameters  - `source`: A pointer to the compressed data.  # Returns  The length of the decompressed data at `source`.  # Safety  Function is safe as long as the pointer points to valid PRS compressed data with a terminator byte.</summary>
        [DllImport(__DllName, EntryPoint = "prs_calculate_decompressed_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint prs_calculate_decompressed_size(byte* src);

        /// <summary>Decompresses PRS compressed data, in an unsafe manner, without any error handling.  # Parameters  - `source`: A pointer to the compressed data. - `destination`: A pointer to the decompressed data.  # Returns  - The length of the decompressed data.  # Remarks  The length of the decompressed data at `destination` should be sufficient to store the decompressed data.  If you know the length of the compressed data (i.e. amount of bytes until end of compressed data), call [`crate::util::prs_calculate_max_decompressed_size`] to get the length of the decompressed data buffer.  If you are unsure of the length, you use the [`crate::estimate::prs_calculate_decompressed_size`] function to determine the length of the decompressed data (at expense of some additional overhead).  # Safety  Function is safe as long as the source points to valid PRS compressed data with a terminator byte. The destination should be large enough to store the decompressed data.</summary>
        [DllImport(__DllName, EntryPoint = "prs_decompress", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint prs_decompress(byte* src, byte* dest);


    }



}
    